function PPopt(FolderName,data_filename,K,out_index)
%K = 0.2; % K=0 for pure pareto front.
data_filename
%% Globals and objective [obj(i) = 1] preferences

clc
global LB UB obj
global Setslog figure_handle no_x no_y lattice
global generation F_bad setno

RandStream('mt19937ar','seed', sum(100*clock));
figure_handle = [];

plst = {'\PP_util' '\util'};
for i = 1:length(plst)
    path([pwd plst{i}], path);
end
%% objectives = [1,1,1...]
%set 1 for min and -1 for max

obj = [-1,-1,1];
n_obj = length(obj);
assert(length(obj)==length(out_index))

%% [Make sure all variables are right]
%Getting Filenames of the Trained Neural Net (generated by PPNNGA_subsets) files

start_out_index = out_index(1);
default = {'Trained_'};
%default = {'Setslog2-'};
hidden_nodes = 3;  % Verify hidden_nodes from PPNNGA_subsets

start_out_index = start_out_index-1;

% Generating Filenames
Setslog = {};
for i=1:n_obj %======UPto number of objectives
    Setslog(i) = cellstr(strcat(default,num2str(hidden_nodes),'-',num2str(start_out_index+i),'_',data_filename));
end
Setslog = strcat(FolderName,Setslog)

%{
% if constraint is applicable
%for constraint function introduce Setslog(3) and so on
% Setslog(3) = {'Setslog10-8_data_mod_smb1.mat'};
% Setslog(4) = {'Setslog10-9_data_mod_smb1.mat'};
%loadwlog loads the tree from Setslog file, the prototype:
%loadwlog(Setslog, setno, index);
%setno is the training subset used and index is tree index obtained from
%the pareto front of training, 1 being the tree with lowest error seeting
%setno =0 takes the last training subset and index = 0 sets the default
%tree chosen by BioGP training
%}

%% Importing data using Filenames generated above in `wlog`
LB = []; UB = [];

for i=1:n_obj
    wlog(i) = loadwlog(importdata(Setslog{i}), 0, 0);
    LB = [LB; wlog(i).xmin];
    UB = [UB; wlog(i).xmax];
end
novar = length(wlog(1).in_index);
svstr = sprintf('%s%s%s%s',data_filename(1:end-4),'_K-',num2str(K*100),'_pareto_');


% CAUTION
%{
for i = 1:n_obj
    LB = [LB; wlog(i).xmin];
    UB = [UB; wlog(i).xmax];
end

%}
from_to = [num2str(out_index(1)),'-',num2str(out_index(end))];
svstr = [svstr from_to];
%% defining variables
LB = max(LB); UB = min(UB);

Prey_popsize = 400;         %Initial popsize
no_Prey_preferred = 400;    %Desired popsize
no_new_Prey = 150;          %new prey introduced every KillInterval
Predator_popsize = 140;     %Number of Predators

no_generations = 250;       %max generations
P_move_prey = 0.7;          %Prob with which a Prey moves
P_mut = 0.1;                %prob of choosing a prey for mutation
%Prob of Xover is 1 for every Prey
F_bad = 1e5;                %fitness assigned to preys performing badly
%2D-lattice
no_x = 80;                  %lattice size (no of rows)
no_y = 80;                  %lattice size (no of cols)
KillInterval = 15;          %Interval at which bad preys are eliminated
maxrank = 6;               %maxrank retained at KillInterval
ploton = 0;                 %set 0 for no plots or 1 for plots at every generation
EliteInterval = 10;
nondom_Prey_save =[];
nondom_F_save =[];

%=============================DND=========================================

%% save variables defined above
pareto.variables.Prey_popsize = Prey_popsize;
pareto.variables.no_Prey_preferred = no_Prey_preferred;
pareto.variables.no_new_Prey=no_new_Prey;
pareto.variables.Predator_popsize=Predator_popsize;
pareto.variables.no_generations=no_generations;
pareto.variables.P_move_prey=P_move_prey;
pareto.variables.P_mut=P_mut;
pareto.variables.F_bad=F_bad;
pareto.variables.no_x=no_x;
pareto.variables.no_y =no_y ;
pareto.variables.KillInterval=KillInterval;
pareto.variables.maxrank =maxrank ;

%% Plotting Code
%caution
%Setslog={};
Setslog.generations = no_generations;
Setslog.ploton = ploton;
Setslog.Predator_popsize = Predator_popsize; Setslog.Prey_popsize = Prey_popsize;
if Setslog.ploton
    figure_handle = [figure(1) figure(2) figure(3) figure(4)];
    scrsz = get(0,'ScreenSize'); setno = [];
    set(figure_handle(1), 'OuterPosition', [0*scrsz(3) scrsz(4)/2 scrsz(3)/2 scrsz(4)/2]); clf
    set(figure_handle(2), 'OuterPosition', [scrsz(3)/2 scrsz(4)/2 scrsz(3)/2 scrsz(4)/2]); clf
    set(figure_handle(3), 'OuterPosition', [0*scrsz(3) 0*scrsz(4) scrsz(3)/2 scrsz(4)/2]); clf
    set(figure_handle(4), 'OuterPosition', [scrsz(3)/2 0*scrsz(4) scrsz(3)/2 scrsz(4)/2]); clf
    pause(1)
end


%**************************************************
%% Lattice initialisation
lattice = zeros(no_x+2,no_y+2);
%% initialization and location of Prey_pop

Prey = rand(Prey_popsize,novar);
for i = 1:novar
    Prey(:,i) = Prey(:,i)*(UB(i)-LB(i))+LB(i);
end

    %location of prey
for i = 1:length(Prey)
    [emptyx,emptyy] = find(lattice(2:no_x+1,2:no_y+1) == 0);
    if ~isempty(emptyx > 0)
        j = ceil(rand*(length(emptyx)));
        lattice(emptyx(j)+1,emptyy(j)+1) = i;
    end
end

  %==============================================================================
%% initialization and location of Predator_pop

Predators = rand(Predator_popsize, n_obj);
Predators_sum = sum(Predators,2);
Predators_broadcast = repmat(Predators_sum,1,n_obj);
Predators = Predators./Predators_broadcast;

%Make sure that the predator is initialised Properly
Predators_sum = sum(Predators,2);
tol = 1.0e-14;
assert(isequal(abs(Predators_sum-ones(Predator_popsize,1))<repmat(tol,Predator_popsize,1),ones(Predator_popsize,1)),'Predator not initialised properly');

% location of predators
for i = 1:length(Predators(:,1))
    [emptyx,emptyy] = find(lattice(2:no_x+1,2:no_y+1) == 0);
    if ~isempty(emptyx > 0)
        j = ceil(rand*(length(emptyx)));
        lattice(emptyx(j)+1,emptyy(j)+1) = -i; %Predator indentified with neg values
    end
end
MovePrey(0, 0, 0);

%% GENERATIONS
for generation = 1:no_generations
    Prey_new = [];
    len = length(Prey(:,1));
    % Move of prey /10 trials /1step
    for i = 1:len
        if rand < P_move_prey
            %Identify location
            [xpos,ypos] = find(lattice(2:no_x+1,2:no_y+1) == i);
            xpos = xpos+1; ypos = ypos+1;
            for j = 1:10 %10 trial for free spot
                dx = round(rand*(3-eps)-1.5); %-1 to the left, 0 no move, 1 to the right
                dy = round(rand*(3-eps)-1.5); %-1 down, 0 no move, 1 up
                if lattice(xpos+dx,ypos+dy) == 0
                    lattice(xpos,ypos) = 0; %removing prey i
                    MovePrey(xpos+dx, ypos+dy, i); break
                end
            end
        end
    end

        % Breeding of prey
    for i = 1:len
        [xpos,ypos] = find(lattice(2:no_x+1,2:no_y+1) == i);
        xpos = xpos+1; ypos = ypos+1;
        moore = lattice(xpos-1:xpos+1,ypos-1:ypos+1);
        %Remove the i-prey
        moore(2,2) = 0;
        [matex,matey] = find(moore >= 1 & moore <= len);
        if ~isempty(matex)
            parent2 = ceil(rand*length(matex));
            parent2 = lattice(xpos-2+matex(parent2),ypos-2+matey(parent2));
            %**********Crossover*********************
            Offspring = Prey([i;parent2],:);
            Offspring = XOVER(Offspring);
            %**********Mutations*********************
            for j = 1:2
                if rand < P_mut
                    Offspring(j,:) = MUTE(Offspring(j,:), generation);
                end
            end
            %Random location of offspring /10 trials
            %Placing offsprings
            for l = 1:2
                for j = 1:10 %10 trial for free spot
                    xpos = round(rand(1,1)*(no_x-1)+1)+1;
                    ypos = round(rand(1,1)*(no_y-1)+1)+1;
                    if lattice(xpos,ypos) == 0
                        Prey = [Prey; Offspring(l,:)];
                        lattice(xpos,ypos) = length(Prey(:,1));
                        break
                    end
                end
            end
        end
        MovePrey(0, 0, 0);
    end

    %update Prey_popsize
    Prey_popsize = length(Prey(:,1));

    F = zeros(Prey_popsize,n_obj);
    for i=1:n_obj
        F(:,i) = obj(i).*evalF(Prey, wlog, i);
    end
    [fonrank, front] = K_dominance_SORT(F,K);


    %{
    F1 = obj(1)*evalF(Prey, wlog, 1);
    F2 = obj(2)*evalF(Prey, wlog, 2);
    [F1 F2] = contra(Prey, obj(1)*F1, obj(2)*F2, wlog);
    F1 = obj(1)*F1;
    F2 = obj(2)*F2;
    %}

    % Removing all except rank n
    if generation/KillInterval == round(generation/KillInterval)
        if generation == no_generations
            maxrank = 0;
        else
            Prey_new = rand(no_new_Prey,novar);
            for i = 1:novar
                Prey_new(:,i) = Prey_new(:,i)*(UB(i)-LB(i))+LB(i);
            end
        end

        %=========================================================
        %Tagging Bad Solutions
        indfr = fonrank > maxrank;
        F(indfr,:) = F_bad + eps;

        %=========================================================
        [Prey, F] = KillBadPrey(Prey, F);
        Prey_popsize = length(Prey(:,1));
        [fonrank, front] = K_dominance_SORT(F,K);

        %=========================================================
    end

    % Move of predators /killing
    % a tinge of doubt
    %What if there are mutliple ``infinite`` crowding distances?
    crodit = CROW_SORT(F, front);
    f_val = zeros(Prey_popsize,n_obj);
    for i=1:n_obj
        f_val(:,i) = (F(:,i) - min(F(:,i)))./(max(F(:,i)) - min(F(:,i)));
    end

    PredMoves = floor((length(Prey) - no_Prey_preferred)/Predator_popsize);
    fprintf('\nGeneration %i: Predatorpop %i PredMoves %i\n',generation,length(Predators(:,1)),PredMoves);
    fprintf('Preypop before: %i; Preypop after: ', length(Prey(:,1)))
    for i = 1:length(Predators)
        for k = 1:PredMoves
            [xpos, ypos] = find(lattice(2:no_x+1,2:no_y+1) == -i); % FIND PREDATOR LOCATION
            xpos = xpos+1; ypos = ypos+1;
            [matex,matey] = find(lattice(xpos-1:xpos+1,ypos-1:ypos+1) > 0);
            if length(matex) > 1 %prey available
                rows=[];
                for t = 1:length(matex)
                    rows = [rows; lattice(matex(t)+xpos-2,matey(t)+ypos-2)];
                end
                %=========================================================
                %f = (Predators(i)*f1(rows) + (1-Predators(i))*f2(rows)).*(front(rows)-1); % elitism for front = 1

                Predator_i = repmat(Predators(i,:),length(rows),1);
                f = sum(Predator_i.*f_val(rows,:), 2).*(front(rows)-1);

                % a tinge of doubt
                if length(unique(front(rows))) == 1
                    f = (f+1)./(1+crodit(rows));
                end

                %=========================================================
                [~,pos] = max(f);

                j = rows(pos(1)); lattice(xpos,ypos) = 0; %removing predator i5
                [xpos,ypos] = find(lattice(2:no_x+1,2:no_y+1) == j); %find worst Prey in Moore Neighbourhood
                xpos = xpos+1; ypos = ypos+1;
                % i = predator ; j = (worst) prey to kill
                Prey = MovePredator(Prey, xpos, ypos, i, j);
                %f1(j) = []; f2(j) = [];
                f_val(j,:)=[]; F(j,:)=[];
                front(j) = []; crodit(j) = []; fonrank(j) = [];
            else %Only move
                for j=1:10 %10 trial for free spot
                    dx=round(rand(1,1)*(3-eps)-1.5); %-1 to the left, 0 no move, 1 to the right
                    dy=round(rand(1,1)*(3-eps)-1.5); %-1 down, 0 no move, 1 up
                    if lattice(xpos+dx,ypos+dy)==0
                        lattice(xpos,ypos)=0; %removing predator i
                        Prey = MovePredator(Prey, xpos+dx, ypos+dy, i, inf);
                        break
                    end
                end
            end
        end
    end
    fprintf('%i\n' , length(Prey(:,1)))


    PlotLattice
    %=========================================================
    %PlotPareto(obj(2)*F(:,2), obj(1)*F(:,1), fonrank)
    %=========================================================

    % Elitism - Saving Periodically.
    if generation/EliteInterval == round(generation/EliteInterval)
        [~, nondom_front] = NONDOM_SORT(F);
        nondom_Prey_save = [nondom_Prey_save; Prey(nondom_front == 1,:)];
        nondom_F_save = [nondom_F_save ; F(nondom_front==1,:)];
        fprintf('Elite : P=%s, F=%s;',num2str(length(nondom_Prey_save)),num2str(length(nondom_F_save)));
        assert(length(nondom_F_save)==length(nondom_Prey_save),'Elite save Error');
    end

    % Placing new Prey
    for i = 1:length(Prey_new)
        for k = 1:10 %10 trial for free spot
            [emptyx,emptyy] = find(lattice(2:no_x+1,2:no_y+1) == 0);
            if ~isempty(emptyx > 0)
                j = ceil(rand*length(emptyx));
                lattice(emptyx(j)+1,emptyy(j)+1) = length(Prey(:,1)) + 1;
                Prey = [Prey; Prey_new(i,:)]; break
            end
        end
    end

end

%=========================================================

% evalF
for i=1:n_obj
	F(:,i) = obj(i)*evalF(Prey, wlog, i);
end
[fonrank, front] = K_dominance_SORT(F,K);

%{
F1 = obj(1)*evalF(Prey, wlog, 1);
F2 = obj(2)*evalF(Prey, wlog, 2);
[F1 F2] = contra(Prey, obj(1)*F1, obj(2)*F2, wlog);
F1 = obj(1)*F1;
F2 = obj(2)*F2;
[fonrank, front] = NONDOM_SORT([F1 F2]);
%}

pareto.pop = Prey;
pareto.pop_F = F;
pareto.crodit = crodit;
pareto.fonrank = fonrank;
pareto.front = front;
pareto.elite_P = nondom_Prey_save;
pareto.elite_F = nondom_F_save;
pareto.EliteInterval = EliteInterval;

%% Add elites to the original population
all_Prey = [Prey;nondom_Prey_save];
all_F = [F;nondom_F_save];

%PlotPareto(obj(2)*F2, obj(1)*F1, fonrank)
%=========================================================
%% Saves K value used
pareto.K = K;

%% Saves First K_non_dominated front, non-repeating solutions
saving = 'Saving First K_non_dominated front...'

[~, front] = K_dominance_SORT(F,K);
Prey_save = Prey(front == 1,:);
F_save = F(front==1,:);

[~,idx] = unique(F_save,'rows','stable');

pareto.P_K = Prey_save(idx,:);
pareto.F_K = F_save(idx,:);
%=========================================================
%% Saves First NON_dominated Pareto Front, non-repeating Solutions
saving = 'Saving First NON_dominated Pareto Front...'
[~, nondom_front] = NONDOM_SORT(F);
nondom_Prey_save = all_Prey(nondom_front == 1,:);
nondom_F_save = all_F(nondom_front==1,:);

[~,idx] = unique(nondom_F_save,'rows','stable');

pareto.P_nondom = nondom_Prey_save(idx,:);
pareto.F_nondom = nondom_F_save(idx,:);


%% Saves only non-repeating solutions from Pareto Front (F1,F2)
%{
f = [(1:length(F1))' F1 F2]; f = sortrows(f, 3); f = sortrows(f, 2); i = 2;

while i ~= length(f(:,1))
    if f(i,2) == f(i-1,2), f(i,:) = []; else i = i+1; end
end

pareto.P = Prey(f(:,1),:);
pareto.F1 = F1(f(:,1));
pareto.F2 = F2(f(:,1));
%}

%% pareto.cons (??)
pareto.cons = [];
if length(wlog) > 2
    for i = 3:length(wlog)
        pareto.cons = [pareto.cons evalF(pareto.P, wlog, i)];
    end
end

svstr
eval(['save ' svstr ' pareto']);


%=========================================================
for i = 1:length(plst)
    rmpath([pwd plst{i}]);
end

end

function wlog = loadwlog(Setslog, setno, index)
wlog.nonodes = Setslog.nonodes;
wlog.noinnodes = Setslog.noinnodes;
wlog.nooutnodes = Setslog.nooutnodes;
wlog.Xmin = Setslog.Xmin;
wlog.Xmax = Setslog.Xmax;
f_index = Setslog.out_index;
wlog.ymin = Setslog.Data_min(1,f_index);
wlog.ymax = Setslog.Data_max(1,f_index);
wlog.xmin = Setslog.Data_min(1,Setslog.in_index);
wlog.xmax = Setslog.Data_max(1,Setslog.in_index);
if index == 0, index = Setslog.dataset(1).pareto.select; end
if setno == 0, setno = Setslog.no_run; end
Net = Setslog.dataset(setno).pareto.P(index);
wlog.w = Net.w;
wlog.W = Net.W;
wlog.in_index = Setslog.in_index;
wlog.out_index = f_index;
end

function bber = evalF(Prey, wlog, oi)

Xmin = wlog(oi).Xmin; Xmax = wlog(oi).Xmax;
ymin = wlog(oi).ymin; ymax = wlog(oi).ymax;
xmin = wlog(oi).xmin; xmax = wlog(oi).xmax;
nonodes = wlog(oi).nonodes; noinnodes = wlog(oi).noinnodes;
nooutnodes = wlog(oi).nooutnodes;
w = wlog(oi).w; W = wlog(oi).W;

in = Prey; noexp = length(in(:,1));

%rescaling the input to actual values
for i = 1:length(wlog(oi).in_index)
    in(:,i) = Xmin + (in(:,i)-xmin(i))/(xmax(i)-xmin(i))*(Xmax-Xmin);
end

%calculating output from neural net.
s = zeros(noexp,1); z = [];
for i = 1:nonodes,
    s(:) = w(i,1)*ones(noexp,1)+((w(i,2:noinnodes+1)*in')');
    z(:,i) = 1./(1+exp(-s(:)));
end
A = [ones(noexp,1) z];
bber = A*W;
for i = 1:nooutnodes
    bber(:,i) = ymin(i)+(ymax(i)-ymin(i))*(bber(:,i)-Xmin)/(Xmax-Xmin);
end
out = bber;
end

function [F1 F2] = contra(Prey, F1, F2, wlog)  % constraint function

% global obj
%
% penalty = 1e1;               % Penalty to be set by user
%
% LB_F = [0.4 0 0.9 0.7];       %set lower bound for F1,F2,F3,F4 and so on respectively
% UB_F = [1 10 1 1];            %set upper bound for F1,F2,F3,F4 and so on respectively
% F3 = evalF(Prey, wlog, 3);
% F4 = evalF(Prey, wlog, 4);
% F = [F1 F2 F3 F4];
% flag = 0;
% for i = 1:length(F1)
%     for j = 1:length(F(1,:))
%         if F(i,j) < LB_F(j) || F(i,j) > UB_F(j)
%             flag = 1;
%         end
%     end
%     if flag
%         F1(i) = F1(i) + obj(1)*penalty;
%         F2(i) = F2(i) + obj(2)*penalty;
%     end
%     flag = 0;
% end

end
